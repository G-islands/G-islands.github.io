{"pages":[{"title":"about","text":"Nothing Here","link":"/about/index.html"}],"posts":[{"title":"Codeforces 1228E Another Filling the Grid","text":"题意题目链接有一个$n\\times n$的方格，需要在每个格子填入$1-k$的数字，要求每行和每列的数字最小值为1。求满足条件的方案有多少种。 solution 1 DP定义$dp(i,j)$表示已经填满了$i$行且$j$列都包含$1$的方案数。首先，$dp(1,j)=k^j\\cdot C(n,j)$ 。因为只有一行，其中的$j$列对应位置一定是$1$。接下来考虑dp的转移。显然$dp(i,j)$需要从$dp(i-1,y)\\ y&lt;j$转移得到。当$y=j\\ j=1$时，只有一列的位置可以填$1$，所以这个位置必须填$1$，否则不满足每行的最小值等于$1$。其余位置因为最小值不唯$1$，所以可以填大于$1$的任意数字，所以方案数等于$$dp(i-1,j)\\cdot (k-1)^{n-j}$$当$y=j\\ j&gt;1$时，最小值等于$1$的若干列只要保证有一个$1$就可以满足这一行的最小值等于$1$，因此只考虑最小值等与$1$的列对$dp(i,j)$的贡献为$k^j-(k-1)^j$，其余的列同理取大于1的任意数字。所以$$dp(i,j)+=dp(i-1,j)\\cdot (k^j-(k-1)^j)\\cdot (k-1)^{n-j}$$同时$dp(i,j)$还可以在$dp(i-1,y)$的基础上在一些新的列的位置填上$1$从而使最小值为$1$的列的数量变为$j$。因此：当$y&lt;j$时，从最小值不为$1$的$n-y$列中选出$j-y$列让他们的最小值变为1，也就是在这一行的对应位置填上$1$，而原本最小值已经为$1$的列因为本行已经保证了有$1$从而使行的最小值等于1，因此这些列任取$[1,k]$的任何数。而其他的$n-j$列只能取$[2,k]$的数字。因此对$dp(i,j)$的贡献为$$dp(i,y)\\cdot C(n-y,j-y)\\cdot k^y\\cdot (k-1)^{n-j}$$预处理$k^i$和$(k-1)^i$，时间复杂度为$O(n^3)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std;#define for0(i, n) for (int i = 0; i &lt; n; i++)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define dec0(i, n) for (int i = n - 1; i &gt;= 0; i--)#define dec1(i, n) for (int i = n; i &gt;= 1; i--)#define mem(a, val) memset(a, val, sizeof(a))#define IO \\ ios::sync_with_stdio(0); \\ cin.tie(0); \\ cout.tie(0);#define ll long long#define db double#define ull unsigned long long#define pb push_back#define mp make_pair#define pii pair&lt;int, int&gt;#define pll pair&lt;ll, ll&gt;#define veci vector&lt;int&gt;#define vecl vector&lt;ll&gt;const ll mod = 1e9 + 7;ll mypow(ll a, ll n, ll mod) { ll ans = 1; while (n) { if (n &amp; 1) ans = ans * a % mod; a = a * a % mod; n &gt;&gt;= 1; } return ans;}const int N = 250;ll dp[300][300];ll A[300], inv[300];ll p1[300], p[300];ll C(ll n, ll m) { if (n == m || m == 0) return 1; return A[n] * inv[m] % mod * inv[n - m] % mod;}void init(int k) { A[1] = 1; for (int i = 2; i &lt;= N; i++) { A[i] = A[i - 1] * i % mod; } inv[N] = mypow(A[N], mod - 2, mod); dec1(i, N - 1) inv[i] = inv[i + 1] * (i + 1) % mod; p1[0] = p[0] = 1; for1(i, N) p1[i] = p1[i - 1] * (k - 1) % mod; for1(i, N) p[i] = p[i - 1] * k % mod;}int main() {#ifdef LOCAL freopen(\"datain\", \"r\", stdin); freopen(\"out\", \"w\", stdout);#endif IO; int n, k; cin &gt;&gt; n &gt;&gt; k; init(k); for (int i = 1; i &lt;= n; i++) { dp[1][i] = p1[n - i] * C(n, i) % mod; } for (int i = 2; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { if (j == 1) dp[i][j] = dp[i - 1][j] * p1[n - j] % mod; else dp[i][j] = dp[i - 1][j] * (p[j] - p1[j] + mod) % mod * p1[n - j] % mod; for (int kk = 1; kk &lt; j; kk++) { dp[i][j] += dp[i - 1][kk] * C(n - kk, j - kk) % mod * p[kk] % mod * p1[n - j] % mod; dp[i][j] %= mod; } } } cout &lt;&lt; dp[n][n] &lt;&lt; endl;} solution 2 容斥定理待补坑","link":"/post/Codeforces-1228E-Another-Filling-the-Grid/"},{"title":"2016 ccpc final B Wash","text":"题意题目链接有$l$件衣服，$n$台洗衣机$m$台烘干机。给出洗衣机和烘干机完成一件所需的时间，洗完的衣服可以无限堆放起来，问洗完且烘干所有衣服的最少时间。 solution对于洗衣服来说，贪心策略显然是选择最先可以洗完当前这件衣服的洗衣机。使用优先队列维护最快洗完之前的衣服且加上当前这件衣服的洗衣机。同时可以得到每件衣服洗完的时间。当烘干衣服时，策略是越晚洗完的衣服就要越快烘干才能缩短总时间。因此需要倒序处理每件衣服。维护方法和洗衣服类似。但是这里优先队列里维护的是连续烘干x件衣服所花的时间。因为是逆时间序处理，如果烘干机连续工作则$a[i]+node.t+node.w$表示当前这件作为这个烘干机的第一件，烘干后几个衣服所花的时间。如果烘干机不连续工作则这个无实际意义。因为对于一台特定的烘干机，他的最终完成时间完全取决于最终连续工作的时间$node.t+node.w$和开始连续工作的起始时间$a[i]$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;#define for0(i, n) for (int i = 0; i &lt; n; i++)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define dec0(i, n) for (int i = n - 1; i &gt;= 0; i--)#define dec1(i, n) for (int i = n; i &gt;= 1; i--)#define mem(a, val) memset(a, val, sizeof(a))#define IO \\ ios::sync_with_stdio(0); \\ cin.tie(0); \\ cout.tie(0);#define ll long long#define db double#define ull unsigned long long#define pb push_back#define mp make_pair#define pii pair&lt;int, int&gt;#define pll pair&lt;ll, ll&gt;#define veci vector&lt;int&gt;#define vecl vector&lt;ll&gt;struct node { ll t, w; ll id; bool operator&lt;(const node&amp; tmp) const { return t + w &gt; tmp.t + tmp.w; }};ll a[1000010];int main() { IO; int t; cin &gt;&gt; t; for (int cas = 1; cas &lt;= t; cas++) { ll l, n, m; cin &gt;&gt; l &gt;&gt; n &gt;&gt; m; priority_queue&lt;node&gt; q1, q2; for1(i, n) { ll tmp; cin &gt;&gt; tmp; q1.push((node){0, tmp, 0}); } for1(i, m) { ll tmp; cin &gt;&gt; tmp; q2.push((node){0, tmp, i}); } for1(i, l) { node tmp = q1.top(); q1.pop(); a[i] = tmp.t + tmp.w; tmp.t += tmp.w; q1.push(tmp); } ll ans = 0; dec1(i, l) { node tmp = q2.top(); q2.pop(); ans = max(ans, tmp.t + tmp.w + a[i]); tmp.t += tmp.w; q2.push(tmp); } cout &lt;&lt; \"Case #\" &lt;&lt; cas &lt;&lt; \": \" &lt;&lt; ans &lt;&lt; endl; }}","link":"/post/2016-ccpc-final-B-Wash/"},{"title":"gym101889J Jumping frog","text":"题意题目链接有一个圆环，圆环上顺时针顺序标着$0\\sim n-1$的点，在这个圆环上有些点是石头有些点是池塘。现在有一只青蛙，每次从一个点顺时针方向跳到另一个点上，跳的步长为k，k的范围是$1\\sim n-1$且每次跳跃步长都相同。例如从点$i$起跳，则落点为$(i+k)%n$。如果存在一个石头作为起点，以步长k顺时针跳跃不落进池塘且回到起点就乘这个步长是可行的。问有多少步长可行。 solution先不考虑池塘的影响，假设没有池塘的限制，从任意一点出发以步长为k跳跃当他回到起点时会经过的点是有规律分布的。首先，当青蛙回到起点所跳跃的总距离等于$lcm(k,n)$。假设他从0点出发，一定会经过的点为$x\\cdot k%n$这些点构成的群的阶数一定是n的因子（由拉格朗日定理得证）。设这个群的阶数为$p$，则步长和阶数满足$p\\cdot k=n$。因此只需要check n的因子的步长即可。当步长不是n的因子时，不能只绕一圈就回到起点，$gcd(k,n)$是绕一圈就回到起点的等价的步长。经过取gcd已经等价的将步长转化为了n的因子，这样保证绕一圈就可以回到原点。在同一个路径上的点模k的值相同，这是显然的。所以只需要把池塘对k取模的值标记，就表示这个路径不可取。如果$0\\sim k$还有点未被标记，则说明以这个点作为起点不会经过池塘回到他自己。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;#define for0(i, n) for (int i = 0; i &lt; n; i++)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define dec0(i, n) for (int i = n - 1; i &gt;= 0; i--)#define dec1(i, n) for (int i = n; i &gt;= 1; i--)#define mem(a, val) memset(a, val, sizeof(a))#define IO \\ ios::sync_with_stdio(0); \\ cin.tie(0); \\ cout.tie(0);#define ll long long#define db double#define ull unsigned long long#define pb push_back#define mp make_pair#define pii pair&lt;int, int&gt;#define pll pair&lt;ll, ll&gt;#define veci vector&lt;int&gt;#define vecl vector&lt;ll&gt; bool vis[100010];int cnt[100010];int main() {#ifdef LOCAL freopen(\"datain\", \"r\", stdin); freopen(\"out\", \"w\", stdout);#endif IO; string s; cin &gt;&gt; s; vector&lt;int&gt; factor, p; int n = s.length(); for0(i, n) { if (s[i] == 'P') p.pb(i); } for (int i = 1; i &lt; n; i++) { cnt[__gcd(i, n)]++; } if (p.size() == 0) { cout &lt;&lt; n - 1 &lt;&lt; endl; return 0; } for (int i = 1; i &lt;n; i++) { if (n % i == 0) factor.pb(i); } int ans = 0; for (int i = 0; i &lt; factor.size(); i++) { for (int j = 0; j &lt; factor[i]; j++) vis[j] = 1; for (int j = 0; j &lt; p.size(); j++) { vis[p[j] % factor[i]] = 0; } for (int j = 0; j &lt; factor[i]; j++) { if (vis[j]) { ans += cnt[factor[i]]; // cout &lt;&lt; factor[i] &lt;&lt; endl; break; } } } cout &lt;&lt; ans &lt;&lt; endl;}","link":"/post/gym101889J-Jumping-frog/"},{"title":"gym101889E Enigma","text":"题意题目链接给出一个数字s，某些数位为？。一个整数n。在？的位置可以填上任意数字，保证结果不可以出现前导零，求最小的能被n整除的数字。不存在则输出*。 solution一开始想到正着dp，结果发现如果在dp转移的时候出现多个前驱状态都可以转移到当前点，就必须比较这些dp状态所对应的数字前缀的大小，复杂度就变为$O(n^3)$了，如果倒着dp那么比较大小只需要比较前一位，就优雅多了。没多想想别的做法就碰瓷，写代码越写越丑，导致时间不够来不及写正确做法。 定义dp[i][j]表示从已经放置了数字的$i\\sim n-1$位且放置了的部分模n等于j的数字（字符串形式），p为最高位数字的权值。这样就很简单了，当前这一位不为？时：$$dp[i][(j+(s[i]-‘0’)*p)%n]=dp[i][j]+s[i]$$ 当这一位为？时就要枚举这一位放的数字 $$dp[i][(j+k*p)%n]=dp[i][j]+char(k+’0’)$$要注意当n=1时需要特判，且n=1，s=”?”时答案应该等于0，这是满足没有前导零的条件的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;#define for0(i, n) for (int i = 0; i &lt; n; i++)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define dec0(i, n) for (int i = n - 1; i &gt;= 0; i--)#define dec1(i, n) for (int i = n; i &gt;= 1; i--)#define mem(a, val) memset(a, val, sizeof(a))#define IO \\ ios::sync_with_stdio(0); \\ cin.tie(0); \\ cout.tie(0);#define ll long long#define db double#define ull unsigned long long#define pb push_back#define mp make_pair#define pii pair&lt;int, int&gt;#define pll pair&lt;ll, ll&gt;#define veci vector&lt;int&gt;#define vecl vector&lt;ll&gt;string dp[2][1010];int main() {#ifdef LOCAL freopen(\"datain\", \"r\", stdin); freopen(\"out\", \"w\", stdout);#endif IO; string s; int n; cin &gt;&gt; s &gt;&gt; n; int p = 0; int x = 1; if (n == 1) { if (s == \"?\") { cout &lt;&lt; 0 &lt;&lt; endl; return 0; } for (int i = 0; i &lt; s.length(); i++) { if (s[i] == '?') { if (i != 0) s[i] = '0'; else s[i] = '1'; } } cout &lt;&lt; s &lt;&lt; endl; return 0; } for (int i = s.length() - 1; i &gt;= 0; i--) { for (int j = 0; j &lt; n; j++) dp[p][j] = \"\"; if (i == s.length() - 1) { if (s[i] == '?') { for (int k = 0; k &lt; 10; k++) { if (k == 0 &amp;&amp; i == 0) continue; if (dp[p][k % n] == \"\") dp[p][k % n] += char(k + '0'); } } else { dp[p][(s[i] - '0') % n] += s[i]; } } else { if (s[i] == '?') { for (int j = 0; j &lt; n; j++) { if (dp[(p + 1) % 2][j] == \"\") continue; for (int k = 0; k &lt; 10; k++) { if (i == 0 &amp;&amp; k == 0) continue; if (dp[p][(j + k * x) % n] != \"\") { if (dp[p][(j + k * x) % n].back() &gt; char(k + '0')) { dp[p][(j + k * x) % n] = dp[(p + 1) % 2][j] + char(k + '0'); } } else { dp[p][(j + k * x) % n] = dp[(p + 1) % 2][j] + char(k + '0'); } } } } else { for (int j = 0; j &lt; n; j++) { if (dp[(p + 1) % 2][j] == \"\") continue; if (dp[p][(j + (s[i] - '0') * x) % n] != \"\") { dp[p][(j + (s[i] - '0') * x) % n] = dp[(p + 1) % 2][j] + s[i]; } else { dp[p][(j + (s[i] - '0') * x) % n] = dp[(p + 1) % 2][j] + s[i]; } } } } p = (p + 1) % 2; x *= 10; x %= n; } p = (p + 1) % 2; if (dp[p][0].length() == s.length()) { reverse(dp[p][0].begin(), dp[p][0].end()); cout &lt;&lt; dp[p][0] &lt;&lt; endl; } else cout &lt;&lt; \"*\" &lt;&lt; endl;}","link":"/post/gym101889E-Enigma/"},{"title":"icarus主题配置","text":"主题配置参考自此–&gt;博客地址 post和page页不显示右侧边栏12345678910111213141516171819202122232425262728293031323334353637383940diff --git a/includes/helpers/layout.js b/includes/helpers/layout.jsindex 7fd6c07..6bfd0b3 100644--- a/includes/helpers/layout.js+++ b/includes/helpers/layout.js@@ -32,6 +32,9 @@ module.exports = function (hexo) { hexo.extend.helper.register('column_count', function () { let columns = 1;+ if (this.page.__post === true || this.page.__page === true) {+ return 2;+ } const hasColumn = hexo.extend.helper.get('has_column').bind(this); columns += hasColumn('left') ? 1 : 0; columns += hasColumn('right') ? 1 : 0;diff --git a/layout/common/widget.ejs b/layout/common/widget.ejsindex 9f58bd5..c6b267c 100644--- a/layout/common/widget.ejs+++ b/layout/common/widget.ejs@@ -25,7 +25,7 @@ &lt;%- partial('widget/' + widget.type, { widget, post: page }) %&gt; &lt;% }) %&gt; &lt;% if (position === 'left') { %&gt;- &lt;div class=\"column-right-shadow is-hidden-widescreen &lt;%= sticky_class('right') %&gt;\"&gt;+ &lt;div class=\"column-right-shadow &lt;%= (page.__page !== true &amp;&amp; page.__post !== true) ? 'is-hidden-widescreen' : '' %&gt; &lt;%= sticky_class('right') %&gt;\"&gt; &lt;% get_widgets('right').forEach(widget =&gt; {%&gt; &lt;%- partial('widget/' + widget.type, { widget, post: page }) %&gt; &lt;% }) %&gt;diff --git a/layout/layout.ejs b/layout/layout.ejsindex cf7be87..b76c9e6 100644--- a/layout/layout.ejs+++ b/layout/layout.ejs@@ -21,7 +21,9 @@ &lt;div class=\"columns\"&gt; &lt;div class=\"column &lt;%= main_column_class() %&gt; has-order-2 column-main\"&gt;&lt;%- body %&gt;&lt;/div&gt; &lt;%- partial('common/widget', { position: 'left' }) %&gt;+ &lt;% if (page.__page !== true &amp;&amp; page.__post !== true) { %&gt; &lt;%- partial('common/widget', { position: 'right' }) %&gt;+ &lt;% } %&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; 文章区域增宽这个文章内容区域是12格布局，可以修改source/css/style.styl文件中的@media screen样式如下： 123456789101112@media screen and (min-width: screen-widescreen) .is-1-column .container .is-2-column .container max-width: screen-widescreen - 2 * gap width: screen-widescreen - 2 * gap@media screen and (min-width: screen-fullhd) .is-2-column .container· max-width: screen-fullhd - 2 * gap width: screen-fullhd - 2 * gap .is-1-column .container max-width: screen-desktop - 2 * gap width: screen-desktop - 2 * gap 再修改layout/layout.ejs和layout/common/widget.ejs的文件内容如下： 1234567891011121314151617181920 &lt;% function main_column_class() { switch (column_count()) { case 1: return &apos;is-12&apos;; case 2: return &apos;is-8-tablet is-9-desktop is-9-widescreen&apos;; case 3: return &apos;is-8-tablet is-8-desktop is-6-widescreen&apos; } return &apos;&apos;; } %&gt;&lt;% function side_column_class() { switch (column_count()) { case 2: return &apos;is-4-tablet is-3-desktop is-3-widescreen&apos;; case 3: return &apos;is-4-tablet is-4-desktop is-3-widescreen&apos;; } return &apos;&apos;;} %&gt; 代码字体和大小设置打开/themes/icarus/source/style.styl 338行开始修改为如下 123456789101112131415161718192021222324252627/* --------------------------------- * Fix content elements * --------------------------------- */.content h1, h2, h3, h4, h5, h6 font-weight: 400 h1 font-size: 1.75em h2 font-size: 1.5em h3 font-size: 1.25em h4 font-size: 1.125em h5 font-size: 1em code, pre font-size: 1em font-family: Consolas code color: hsl(348, 100%, 61%) background: transparent padding: 0 blockquote footer strong + cite margin-left: 0.5em","link":"/post/icarus主题配置/"}],"tags":[{"name":"dp","slug":"dp","link":"/tags/dp/"},{"name":"combinatorics","slug":"combinatorics","link":"/tags/combinatorics/"},{"name":"greedy","slug":"greedy","link":"/tags/greedy/"},{"name":"math","slug":"math","link":"/tags/math/"}],"categories":[{"name":"solution","slug":"solution","link":"/categories/solution/"},{"name":"others","slug":"others","link":"/categories/others/"}]}